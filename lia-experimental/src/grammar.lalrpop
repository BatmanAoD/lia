use std::str::FromStr;
use super::token::Token;
use super::mark::{Mark, DUMMY};
use super::ast::{term, typ};
use super::ast::term::{Term, View as TermV};
use super::ast::typ::{Typ, View as TypV};
use rabbot::var::Var;

grammar;

extern {
    type Location = u32;

    enum Token {
        Let => Token::Let,
        Eq => Token::Eq,
        Semi => Token::Semi,
        Plus => Token::Plus,
        Int => Token::Int(<i32>),
        Lparen => Token::Lparen,
        Rparen => Token::Rparen,
        Lbrace => Token::Lbrace,
        Rbrace => Token::Rbrace,
        QuoteMarker => Token::QuoteMarker,
        Fun => Token::Fun,
        Arrow => Token::Arrow,
        QuoteChar => Token::QuoteChar(<String>),
        Splice => Token::Splice(<String>),
        IdT => Token::Id(<String>),
        TyPrimitive => Token::TyPrimitive(<String>),
        String => Token::String(<String>),
    }
}

Meta<S, T>: term::Meta<T> = {
    <lo:@L> <s:S> <hi:@L> => {
        term::Meta {
            val: s,
            mark: Mark { lo: lo, hi: hi },
            typ: typ::into(typ::Meta {
              val: TypV::Hole,
              mark: DUMMY.clone(),
            })
        }
    }
};

// Dummy definitions to work with the LALRPOP type system
Term: Term = {};
Var: Var = {};
TermV: TermV = {};

M<T>: Term = {
    Meta<T, TermV> => term::into(<>)
};

Typ: Typ = {

};

pub Toplevel: Term = { M<Block> };

Block: TermV = {
    Let <id:Id> Eq <bind:M<Prec0>> Semi <body:M<Block>> =>
        TermV::Let((bind, (id, body))),
    <l:M<Prec0>> Semi <r:M<Block>> =>
        TermV::Let((l, (Var::from_string("dummy".to_string()), r))),
    Prec0
};

Prec0: TermV = {
    <l:M<Prec0>> <r:M<Prec1>> => TermV::App((l, r)),
    Prec1
};

Prec1: TermV = {
    Fun <id:Id> Arrow <e:M<Prec1>> => TermV::Lam((id, e)),
    Prec2
};

Prec2: TermV = {
    <l:M<Prec2>> Plus <r:M<Prec3>> => TermV::Plus((l, r)),
    Prec3
};

Prec3: TermV = {
    Int => TermV::Number(<>),
    Meta<Id, Var> => term::var(<>),
    String => TermV::String(<>),
    Lparen <e:Block> Rparen => e,
    Lbrace <e:Block> Rbrace => e,
    QuoteMarker Lbrace <q:M<QuotePart>*> Rbrace => TermV::Quote(q)
};

StringToVar<T>: Var = {
    T => Var::from_string(<>)
};

QuotePart: TermV = {
    QuoteChar => TermV::String(<>),
    Meta<StringToVar<Splice>, Var> => term::var(<>)
};

Id: Var = { StringToVar<IdT> };
